{"version":3,"file":"storage.js","sources":["../node_modules/@webreflection/idb-map/index.js","../node_modules/@webreflection/idb-map/sync.js","../node_modules/flatted/esm/index.js","../src/storage.js"],"sourcesContent":["const { assign } = Object;\n\nconst STORAGE = 'entries';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\n/**\n * @typedef {Object} IDBMapOptions\n * @prop {'strict' | 'relaxed' | 'default'} [durability]\n * @prop {string} [prefix]\n */\n\n/** @typedef {[IDBValidKey, unknown]} IDBMapEntry */\n\n/** @type {IDBMapOptions} */\nconst defaultOptions = { durability: 'default', prefix: 'IDBMap' };\n\n/**\n * @template T\n * @param {{ target: IDBRequest<T> }} event\n * @returns {T}\n */\nconst result = ({ target: { result } }) => result;\n\nexport default class IDBMap extends EventTarget {\n  // Privates\n  /** @type {Promise<IDBDatabase>} */ #db;\n  /** @type {IDBMapOptions} */ #options;\n  /** @type {string} */ #prefix;\n\n  /**\n   * @template T\n   * @param {(store: IDBObjectStore) => IDBRequest<T>} what\n   * @param {'readonly' | 'readwrite'} how\n   * @returns {Promise<T>}\n   */\n  async #transaction(what, how) {\n    const db = await this.#db;\n    const t = db.transaction(STORAGE, how, this.#options);\n    return new Promise((onsuccess, onerror) => assign(\n      what(t.objectStore(STORAGE)),\n      {\n        onsuccess,\n        onerror,\n      }\n    ));\n  }\n\n  /**\n   * @param {string} name\n   * @param {IDBMapOptions} options\n   */\n  constructor(\n    name,\n    {\n      durability = defaultOptions.durability,\n      prefix = defaultOptions.prefix,\n    } = defaultOptions\n  ) {\n    super();\n    this.#prefix = prefix;\n    this.#options = { durability };\n    this.#db = new Promise((resolve, reject) => {\n      assign(\n        indexedDB.open(`${this.#prefix}/${name}`),\n        {\n          onupgradeneeded({ target: { result, transaction } }) {\n            if (!result.objectStoreNames.length)\n              result.createObjectStore(STORAGE);\n            transaction.oncomplete = () => resolve(result);\n          },\n          onsuccess(event) {\n            resolve(result(event));\n          },\n          onerror(event) {\n            reject(event);\n            this.dispatchEvent(event);\n          },\n        },\n      );\n    }).then(result => {\n      const boundDispatch = this.dispatchEvent.bind(this);\n      for (const key in result) {\n        if (key.startsWith('on'))\n          result[key] = boundDispatch;\n      }\n      return result;\n    });\n  }\n\n  // EventTarget Forwards\n  /**\n   * @param {Event} event\n   * @returns \n   */\n  dispatchEvent(event) {\n    const { type, message, isTrusted } = event;\n    return super.dispatchEvent(\n      // avoid re-dispatching of the same event\n      isTrusted ?\n        assign(new Event(type), { message }) :\n        event\n    );\n  }\n\n  // IDBDatabase Forwards\n  async close() {\n    (await this.#db).close();\n  }\n\n  // Map async API\n  get size() {\n    return this.#transaction(\n      store => store.count(),\n      READONLY,\n    ).then(result);\n  }\n\n  async clear() {\n    await this.#transaction(\n      store => store.clear(),\n      READWRITE,\n    );\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   */\n  async delete(key) {\n    await this.#transaction(\n      store => store.delete(key),\n      READWRITE,\n    );\n  }\n\n  /**\n   * @returns {Promise<IDBMapEntry[]>}\n   */\n  async entries() {\n    const keys = await this.keys();\n    return Promise.all(keys.map(key => this.get(key).then(value => [key, value])));\n  }\n\n  /**\n   * @param {(unknown, IDBValidKey, IDBMap) => void} callback\n   * @param {unknown} [context]\n   */\n  async forEach(callback, context = this) {\n    for (const [key, value] of await this.entries())\n      await callback.call(context, value, key, this);\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   * @returns {Promise<unknown | undefined>}\n   */\n  async get(key) {\n    const value = await this.#transaction(\n      store => store.get(key),\n      READONLY,\n    ).then(result);\n    return value;\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   */\n  async has(key) {\n    const k = await this.#transaction(\n      store => store.getKey(key),\n      READONLY,\n    ).then(result);\n    return k !== void 0;\n  }\n\n  async keys() {\n    const keys = await this.#transaction(\n      store => store.getAllKeys(),\n      READONLY,\n    ).then(result);\n    return keys;\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   * @param {unknown} value\n   */\n  async set(key, value) {\n    await this.#transaction(\n      store => store.put(value, key),\n      READWRITE,\n    );\n    return this;\n  }\n\n  async values() {\n    const keys = await this.keys();\n    return Promise.all(keys.map(key => this.get(key)));\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.#prefix;\n  }\n}\n","import IDBMap from './index.js';\n\nexport default class IDBMapSync extends Map {\n  #map;\n  #queue;\n  constructor(...args) {\n    super();\n    this.#map = new IDBMap(...args);\n    this.#queue = this.#map.entries().then(entries => {\n      for (const [key, value] of entries)\n        super.set(key, value);\n    });\n  }\n  async close() {\n    await this.#queue;\n    await this.#map.close();\n  }\n  async sync() {\n    await this.#queue;\n  }\n  clear() {\n    this.#queue = this.#queue.then(() => this.#map.clear());\n    return super.clear();\n  }\n  delete(key) {\n    this.#queue = this.#queue.then(() => this.#map.delete(key));\n    return super.delete(key);\n  }\n  set(key, value) {\n    this.#queue = this.#queue.then(() => this.#map.set(key, value));\n    return super.set(key, value);\n  }\n}\n","/// <reference types=\"../types/index.d.ts\" />\n\n// (c) 2020-present Andrea Giammarchi\n\nconst {parse: $parse, stringify: $stringify} = JSON;\nconst {keys} = Object;\n\nconst Primitive = String;   // it could be Number\nconst primitive = 'string'; // it could be 'number'\n\nconst ignore = {};\nconst object = 'object';\n\nconst noop = (_, value) => value;\n\nconst primitives = value => (\n  value instanceof Primitive ? Primitive(value) : value\n);\n\nconst Primitives = (_, value) => (\n  typeof value === primitive ? new Primitive(value) : value\n);\n\nconst revive = (input, parsed, output, $) => {\n  const lazy = [];\n  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {\n    const k = ke[y];\n    const value = output[k];\n    if (value instanceof Primitive) {\n      const tmp = input[value];\n      if (typeof tmp === object && !parsed.has(tmp)) {\n        parsed.add(tmp);\n        output[k] = ignore;\n        lazy.push({k, a: [input, parsed, tmp, $]});\n      }\n      else\n        output[k] = $.call(output, k, tmp);\n    }\n    else if (output[k] !== ignore)\n      output[k] = $.call(output, k, value);\n  }\n  for (let {length} = lazy, i = 0; i < length; i++) {\n    const {k, a} = lazy[i];\n    output[k] = $.call(output, k, revive.apply(null, a));\n  }\n  return output;\n};\n\nconst set = (known, input, value) => {\n  const index = Primitive(input.push(value) - 1);\n  known.set(value, index);\n  return index;\n};\n\n/**\n * Converts a specialized flatted string into a JS value.\n * @param {string} text\n * @param {(this: any, key: string, value: any) => any} [reviver]\n * @returns {any}\n */\nexport const parse = (text, reviver) => {\n  const input = $parse(text, Primitives).map(primitives);\n  const value = input[0];\n  const $ = reviver || noop;\n  const tmp = typeof value === object && value ?\n              revive(input, new Set, value, $) :\n              value;\n  return $.call({'': tmp}, '', tmp);\n};\n\n/**\n * Converts a JS value into a specialized flatted string.\n * @param {any} value\n * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]\n * @param {string | number | undefined} [space]\n * @returns {string}\n */\nexport const stringify = (value, replacer, space) => {\n  const $ = replacer && typeof replacer === object ?\n            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :\n            (replacer || noop);\n  const known = new Map;\n  const input = [];\n  const output = [];\n  let i = +set(known, input, $.call({'': value}, '', value));\n  let firstRun = !i;\n  while (i < input.length) {\n    firstRun = true;\n    output[i] = $stringify(input[i++], replace, space);\n  }\n  return '[' + output.join(',') + ']';\n  function replace(key, value) {\n    if (firstRun) {\n      firstRun = !firstRun;\n      return value;\n    }\n    const after = $.call(this, key, value);\n    switch (typeof after) {\n      case object:\n        if (after === null) return after;\n      case primitive:\n        return known.get(after) || set(known, input, after);\n    }\n    return after;\n  }\n};\n\n/**\n * Converts a generic value into a JSON serializable object without losing recursion.\n * @param {any} value\n * @returns {any}\n */\nexport const toJSON = value => $parse(stringify(value));\n\n/**\n * Converts a previously serialized object with recursion into a recursive one.\n * @param {any} value\n * @returns {any}\n */\nexport const fromJSON = value => parse($stringify(value));\n","import IDBMapSync from \"@webreflection/idb-map/sync\";\nimport { parse, stringify } from \"flatted\";\n\nconst { isView } = ArrayBuffer;\n\nconst to_idb = (value) => {\n    if (value == null) return stringify([\"null\", 0]);\n    /* eslint-disable no-fallthrough */\n    switch (typeof value) {\n        case \"object\": {\n            if (isView(value)) return stringify([\"memoryview\", [...value]]);\n            if (value instanceof ArrayBuffer)\n                return stringify([\"bytearray\", [...new Uint8Array(value)]]);\n        }\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return stringify([\"generic\", value]);\n        default:\n            throw new TypeError(`Unexpected value: ${String(value)}`);\n    }\n};\n\nconst from_idb = (value) => {\n    const [kind, result] = parse(value);\n    if (kind === \"null\") return null;\n    if (kind === \"generic\") return result;\n    if (kind === \"bytearray\") return new Uint8Array(value).buffer;\n    if (kind === \"memoryview\") return new Uint8Array(value);\n    return value;\n};\n\n// this export simulate pyscript.storage exposed in the Python world\nexport const storage = async (name) => {\n    if (!name) throw new SyntaxError(\"The storage name must be defined\");\n\n    const store = new IDBMapSync(`@pyscript/${name}`);\n    const map = new Map();\n    await store.sync();\n    for (const [k, v] of store.entries()) map.set(k, from_idb(v));\n\n    const clear = () => {\n        map.clear();\n        store.clear();\n    };\n\n    const sync = async () => {\n        await store.sync();\n    };\n\n    return new Proxy(map, {\n        ownKeys: (map) => [...map.keys()],\n        has: (map, name) => map.has(name),\n        get: (map, name) => {\n            if (name === \"clear\") return clear;\n            if (name === \"sync\") return sync;\n            return map.get(name);\n        },\n        set: (map, name, value) => {\n            map.set(name, value);\n            store.set(name, to_idb(value));\n            return true;\n        },\n        deleteProperty: (map, name) => {\n            if (map.has(name)) {\n                map.delete(name);\n                store.delete(name);\n            }\n            return true;\n        },\n    });\n};\n"],"names":["assign","Object","STORAGE","READONLY","READWRITE","defaultOptions","durability","prefix","result","target","IDBMap","EventTarget","db","options","transaction","what","how","t","this","Promise","onsuccess","onerror","objectStore","constructor","name","super","resolve","reject","indexedDB","open","onupgradeneeded","objectStoreNames","length","createObjectStore","oncomplete","event","dispatchEvent","then","boundDispatch","bind","key","startsWith","type","message","isTrusted","Event","close","size","store","count","clear","delete","entries","keys","all","map","get","value","forEach","callback","context","call","has","getKey","getAllKeys","set","put","values","Symbol","toStringTag","IDBMapSync","Map","queue","args","sync","parse","$parse","stringify","$stringify","JSON","Primitive","String","primitive","ignore","object","noop","_","primitives","Primitives","revive","input","parsed","output","$","lazy","ke","y","k","tmp","add","push","a","i","apply","known","index","replacer","space","firstRun","replace","join","after","isView","ArrayBuffer","from_idb","kind","text","Set","Uint8Array","buffer","storage","async","SyntaxError","v","Proxy","ownKeys","TypeError","to_idb","deleteProperty"],"mappings":"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","x_google_ignoreList":[0,1,2]}