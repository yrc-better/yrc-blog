const{assign:e}=Object,t="entries",s="readonly",n="readwrite",r={durability:"default",prefix:"IDBMap"},a=({target:{result:e}})=>e;class i extends EventTarget{#e;#t;#s;async#n(s,n){const r=(await this.#e).transaction(t,n,this.#t);return new Promise((n,a)=>e(s(r.objectStore(t)),{onsuccess:n,onerror:a}))}constructor(s,{durability:n=r.durability,prefix:i=r.prefix}=r){super(),this.#s=i,this.#t={durability:n},this.#e=new Promise((n,r)=>{e(indexedDB.open(`${this.#s}/${s}`),{onupgradeneeded({target:{result:e,transaction:s}}){e.objectStoreNames.length||e.createObjectStore(t),s.oncomplete=()=>n(e)},onsuccess(e){n(a(e))},onerror(e){r(e),this.dispatchEvent(e)}})}).then(e=>{const t=this.dispatchEvent.bind(this);for(const s in e)s.startsWith("on")&&(e[s]=t);return e})}dispatchEvent(t){const{type:s,message:n,isTrusted:r}=t;return super.dispatchEvent(r?e(new Event(s),{message:n}):t)}async close(){(await this.#e).close()}get size(){return this.#n(e=>e.count(),s).then(a)}async clear(){await this.#n(e=>e.clear(),n)}async delete(e){await this.#n(t=>t.delete(e),n)}async entries(){const e=await this.keys();return Promise.all(e.map(e=>this.get(e).then(t=>[e,t])))}async forEach(e,t=this){for(const[s,n]of await this.entries())await e.call(t,n,s,this)}async get(e){return await this.#n(t=>t.get(e),s).then(a)}async has(e){return void 0!==await this.#n(t=>t.getKey(e),s).then(a)}async keys(){return await this.#n(e=>e.getAllKeys(),s).then(a)}async set(e,t){return await this.#n(s=>s.put(t,e),n),this}async values(){const e=await this.keys();return Promise.all(e.map(e=>this.get(e)))}get[Symbol.toStringTag](){return this.#s}}class c extends Map{#r;#a;constructor(...e){super(),this.#r=new i(...e),this.#a=this.#r.entries().then(e=>{for(const[t,s]of e)super.set(t,s)})}async close(){await this.#a,await this.#r.close()}async sync(){await this.#a}clear(){return this.#a=this.#a.then(()=>this.#r.clear()),super.clear()}delete(e){return this.#a=this.#a.then(()=>this.#r.delete(e)),super.delete(e)}set(e,t){return this.#a=this.#a.then(()=>this.#r.set(e,t)),super.set(e,t)}}const{parse:o,stringify:u}=JSON,{keys:l}=Object,h=String,y="string",p={},f="object",w=(e,t)=>t,d=e=>e instanceof h?h(e):e,g=(e,t)=>typeof t===y?new h(t):t,m=(e,t,s,n)=>{const r=[];for(let a=l(s),{length:i}=a,c=0;c<i;c++){const i=a[c],o=s[i];if(o instanceof h){const a=e[o];typeof a!==f||t.has(a)?s[i]=n.call(s,i,a):(t.add(a),s[i]=p,r.push({k:i,a:[e,t,a,n]}))}else s[i]!==p&&(s[i]=n.call(s,i,o))}for(let{length:e}=r,t=0;t<e;t++){const{k:e,a:a}=r[t];s[e]=n.call(s,e,m.apply(null,a))}return s},b=(e,t,s)=>{const n=h(t.push(s)-1);return e.set(s,n),n},x=(e,t,s)=>{const n=w,r=new Map,a=[],i=[];let c=+b(r,a,n.call({"":e},"",e)),o=!c;for(;c<a.length;)o=!0,i[c]=u(a[c++],l,s);return"["+i.join(",")+"]";function l(e,t){if(o)return o=!o,t;const s=n.call(this,e,t);switch(typeof s){case f:if(null===s)return s;case y:return r.get(s)||b(r,a,s)}return s}},{isView:v}=ArrayBuffer,q=e=>{const[t,s]=(e=>{const t=o(e,g).map(d),s=t[0],n=w,r=typeof s===f&&s?m(t,new Set,s,n):s;return n.call({"":r},"",r)})(e);return"null"===t?null:"generic"===t?s:"bytearray"===t?new Uint8Array(e).buffer:"memoryview"===t?new Uint8Array(e):e},S=async e=>{if(!e)throw new SyntaxError("The storage name must be defined");const t=new c(`@pyscript/${e}`),s=new Map;await t.sync();for(const[e,n]of t.entries())s.set(e,q(n));const n=()=>{s.clear(),t.clear()},r=async()=>{await t.sync()};return new Proxy(s,{ownKeys:e=>[...e.keys()],has:(e,t)=>e.has(t),get:(e,t)=>"clear"===t?n:"sync"===t?r:e.get(t),set:(e,s,n)=>(e.set(s,n),t.set(s,(e=>{if(null==e)return x(["null",0]);switch(typeof e){case"object":if(v(e))return x(["memoryview",[...e]]);if(e instanceof ArrayBuffer)return x(["bytearray",[...new Uint8Array(e)]]);case"string":case"number":case"boolean":return x(["generic",e]);default:throw new TypeError(`Unexpected value: ${String(e)}`)}})(n)),!0),deleteProperty:(e,s)=>(e.has(s)&&(e.delete(s),t.delete(s)),!0)})};export{S as storage};
//# sourceMappingURL=storage.js.map
